<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Text Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
            color: white;
            min-width: 250px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <label>Rotation Y (0-360°): <span class="value-display" id="rotY-value">0°</span></label>
            <input type="range" id="rotY" min="0" max="360" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Rotation X (-90 to 90°): <span class="value-display" id="rotX-value">0°</span></label>
            <input type="range" id="rotX" min="-90" max="90" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Extrusion Depth (1-150): <span class="value-display" id="depth-value">20</span></label>
            <input type="range" id="depth" min="1" max="150" value="20" step="1">
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <script>
        let scene, camera, renderer, textGroup;
        let extrusionDepth = 20;
        let font = null;

        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight1.position.set(5, 10, 7);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xff6b9d, 0.4);
            directionalLight2.position.set(-5, 5, 3);
            scene.add(directionalLight2);

            textGroup = new THREE.Group();
            textGroup.rotation.y = 0;
            textGroup.rotation.x = 0;
            scene.add(textGroup);

            // Load font
            opentype.load('https://cdnjs.cloudflare.com/ajax/libs/topcoat/0.8.0/font/SourceCodePro-Bold.otf', function(err, loadedFont) {
                if (err) {
                    console.error('Font loading error:', err);
                    // Fallback to simple shapes if font fails
                    buildTextSimple();
                } else {
                    font = loadedFont;
                    buildText();
                }
            });

            setupControls();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function buildText() {
            if (!font) {
                buildTextSimple();
                return;
            }

            const text = 'ABCD\nEFGH\nIJKL\nMNOP\nQRST\nUVWX\nYZ01\n2345\n6789';
            const lines = text.split('\n');
            const letterSpacing = 5.5;
            const lineHeight = 7;
            const fontSize = 60;
            
            lines.forEach((line, lineIndex) => {
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const x = i * letterSpacing - (line.length * letterSpacing) / 2 + letterSpacing / 2;
                    const y = -lineIndex * lineHeight + (lines.length * lineHeight) / 2 - lineHeight / 2;
                    createLetterFromFont(char, x, y, 0, fontSize);
                }
            });
        }

        function createLetterFromFont(char, x, y, z, fontSize) {
            const colors = [0xD4789C, 0xD4A95A, 0x6BA3C3, 0xE67E9F, 0xF4B860, 0x5A9BC4];
            const color = colors[char.charCodeAt(0) % colors.length];

            const glyph = font.charToGlyph(char);
            const path = glyph.getPath(0, 0, fontSize);
            
            const shapes = [];
            let currentShape = null;
            
            path.commands.forEach((cmd, index) => {
                if (cmd.type === 'M') {
                    if (currentShape) {
                        shapes.push(currentShape);
                    }
                    currentShape = new THREE.Shape();
                    currentShape.moveTo(-cmd.x / 15, -cmd.y / 15);
                } else if (cmd.type === 'L') {
                    currentShape.lineTo(-cmd.x / 15, -cmd.y / 15);
                } else if (cmd.type === 'C') {
                    currentShape.bezierCurveTo(
                        -cmd.x1 / 15, -cmd.y1 / 15,
                        -cmd.x2 / 15, -cmd.y2 / 15,
                        -cmd.x / 15, -cmd.y / 15
                    );
                } else if (cmd.type === 'Q') {
                    currentShape.quadraticCurveTo(
                        -cmd.x1 / 15, -cmd.y1 / 15,
                        -cmd.x / 15, -cmd.y / 15
                    );
                } else if (cmd.type === 'Z') {
                    currentShape.closePath();
                }
            });
            
            if (currentShape) {
                shapes.push(currentShape);
            }

            if (shapes.length === 0) return;

            // For letters with holes, we need to identify which shapes are holes
            // The largest shape by area is typically the outer shape
            if (shapes.length > 1) {
                // Calculate approximate area for each shape to find the main outline
                const shapesWithArea = shapes.map(shape => {
                    const points = shape.getPoints();
                    let area = 0;
                    for (let i = 0; i < points.length; i++) {
                        const j = (i + 1) % points.length;
                        area += points[i].x * points[j].y;
                        area -= points[j].x * points[i].y;
                    }
                    return { shape, area: Math.abs(area) };
                });

                // Sort by area (largest first)
                shapesWithArea.sort((a, b) => b.area - a.area);
                
                const mainShape = shapesWithArea[0].shape;
                const holes = shapesWithArea.slice(1).map(s => s.shape);
                
                // Add holes to main shape
                holes.forEach(hole => {
                    mainShape.holes.push(hole);
                });

                const extrudeSettings = {
                    depth: extrusionDepth,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 2
                };
                
                const geometry = new THREE.ExtrudeGeometry(mainShape, extrudeSettings);
                geometry.rotateY(Math.PI);
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                textGroup.add(mesh);
            } else {
                // Single shape, no holes
                const extrudeSettings = {
                    depth: extrusionDepth,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 2
                };
                
                const geometry = new THREE.ExtrudeGeometry(shapes[0], extrudeSettings);
                geometry.rotateY(Math.PI);
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                textGroup.add(mesh);
            }
        }

        function buildTextSimple() {
            // Fallback to basic shapes if font loading fails
            console.log('Using fallback simple text');
            const text = 'ABCD\nEFGH\nIJKL\nMNOP\nQRST\nUVWX\nYZ01\n2345\n6789';
            const lines = text.split('\n');
            const letterSpacing = 4.5;
            const lineHeight = 6;
            
            lines.forEach((line, lineIndex) => {
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const x = i * letterSpacing - (line.length * letterSpacing) / 2 + letterSpacing / 2;
                    const y = -lineIndex * lineHeight + (lines.length * lineHeight) / 2 - lineHeight / 2;
                    
                    const colors = [0xD4789C, 0xD4A95A, 0x6BA3C3, 0xE67E9F, 0xF4B860, 0x5A9BC4];
                    const color = colors[char.charCodeAt(0) % colors.length];
                    
                    const geometry = new THREE.BoxGeometry(3, 4, extrusionDepth);
                    const material = new THREE.MeshStandardMaterial({ color: color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    textGroup.add(mesh);
                }
            });
        }

        function setupControls() {
            const rotYSlider = document.getElementById('rotY');
            const rotXSlider = document.getElementById('rotX');
            const depthSlider = document.getElementById('depth');
            const rotYValue = document.getElementById('rotY-value');
            const rotXValue = document.getElementById('rotX-value');
            const depthValue = document.getElementById('depth-value');

            rotYSlider.addEventListener('input', function() {
                const degrees = parseInt(this.value);
                textGroup.rotation.y = degrees * Math.PI / 180;
                rotYValue.textContent = degrees + '°';
            });

            rotXSlider.addEventListener('input', function() {
                const degrees = parseInt(this.value);
                textGroup.rotation.x = degrees * Math.PI / 180;
                rotXValue.textContent = degrees + '°';
            });

            depthSlider.addEventListener('input', function() {
                extrusionDepth = parseInt(this.value);
                depthValue.textContent = extrusionDepth;
                
                while(textGroup.children.length > 0) {
                    textGroup.remove(textGroup.children[0]);
                }
                
                buildText();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
