<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Text Test</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            color: white;
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #2a2a3e;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 14px;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }
        button {
            flex: 1;
            padding: 10px;
            background: #2a2a3e;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button.active {
            background: #3498db;
            border-color: #3498db;
        }
        button:hover {
            background: #3a3a4e;
        }
        button.active:hover {
            background: #2980b9;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <label>Font:</label>
            <select id="fontSelect">
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/source-code-pro@5.0.8/files/source-code-pro-latin-700-normal.woff">Source Code Pro Bold</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/roboto@5.0.8/files/roboto-latin-700-normal.woff">Roboto Bold</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/open-sans@5.0.17/files/open-sans-latin-700-normal.woff">Open Sans Bold</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/pacifico@5.0.10/files/pacifico-latin-400-normal.woff">Pacifico</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/permanent-marker@5.0.9/files/permanent-marker-latin-400-normal.woff">Permanent Marker</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/indie-flower@5.0.10/files/indie-flower-latin-400-normal.woff">Indie Flower</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/press-start-2p@5.0.9/files/press-start-2p-latin-400-normal.woff">Press Start 2P</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/anton@5.0.17/files/anton-latin-400-normal.woff">Anton</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/righteous@5.0.17/files/righteous-latin-400-normal.woff">Righteous</option>
            </select>
        </div>
        <div class="control-group">
            <label>Font Style:</label>
            <div class="button-group">
                <button id="boldBtn" class="active">Bold</button>
                <button id="italicBtn">Italic</button>
            </div>
        </div>
        <div class="control-group">
            <label>Letter Spacing: <span class="value-display" id="spacing-value">1.0</span></label>
            <input type="range" id="spacing" min="0" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Line Spacing: <span class="value-display" id="lineSpacing-value">1.0</span></label>
            <input type="range" id="lineSpacing" min="0.5" max="3" value="1" step="0.1">
        </div>
        <div class="control-group">
            <label>Rotation Y (0-360°): <span class="value-display" id="rotY-value">0°</span></label>
            <input type="range" id="rotY" min="0" max="360" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Rotation X (-90 to 90°): <span class="value-display" id="rotX-value">0°</span></label>
            <input type="range" id="rotX" min="-90" max="90" value="0" step="1">
        </div>
        <div class="control-group">
            <label>Extrusion Depth (1-150): <span class="value-display" id="depth-value">20</span></label>
            <input type="range" id="depth" min="1" max="150" value="20" step="1">
        </div>
        <div class="control-group">
            <label>Z Offset (0-150): <span class="value-display" id="zOffset-value">10</span></label>
            <input type="range" id="zOffset" min="0" max="150" value="10" step="1">
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <script>
        let scene, camera, renderer, textGroup;
        let extrusionDepth = 20;
        let zOffsetMultiplier = 10;
        let font = null;
        let letterSpacingMultiplier = 1.0;
        let lineSpacingMultiplier = 1.0;
        let isBold = true;
        let isItalic = false;
        let currentFontUrl = 'https://cdn.jsdelivr.net/npm/@fontsource/source-code-pro@5.0.8/files/source-code-pro-latin-700-normal.woff';
        let raindropLights = [];
        let letterDepthOffsets = {};

        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
            scene.add(ambientLight);
            
            const light1 = new THREE.PointLight(0xffffdd, 2.5, 80);
            light1.position.set(0, 50, 5);
            light1.castShadow = true;
            scene.add(light1);
            
            const sphere1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffaa })
            );
            light1.add(sphere1);
            
            const light2 = new THREE.PointLight(0xffffdd, 2.5, 80);
            light2.position.set(0, 50, 5);
            light2.castShadow = true;
            scene.add(light2);
            
            const sphere2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffaa })
            );
            light2.add(sphere2);

            raindropLights = [
                { 
                    light: light1, 
                    position: new THREE.Vector3(0, 0, 50),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        -1.5
                    ),
                    baseIntensity: 2.5, 
                    fadeOut: false,
                    fadeFactor: 0,
                    lifetime: 0
                },
                { 
                    light: light2, 
                    position: new THREE.Vector3(0, 0, 50),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        (Math.random() - 0.5) * 0.1,
                        -1.5
                    ),
                    baseIntensity: 2.5, 
                    fadeOut: false,
                    fadeFactor: 0,
                    lifetime: 60
                }
            ];

            textGroup = new THREE.Group();
            textGroup.rotation.y = 0;
            textGroup.rotation.x = 0;
            scene.add(textGroup);

            loadFont(currentFontUrl);

            setupControls();
            window.addEventListener('resize', onWindowResize);
            animate();
        }

        function loadFont(url) {
            opentype.load(url, function(err, loadedFont) {
                if (err) {
                    console.error('Font loading error:', err);
                    buildTextSimple();
                } else {
                    font = loadedFont;
                    rebuildText();
                }
            });
        }

        function buildText() {
            if (!font) {
                buildTextSimple();
                return;
            }

            const text = 'ABCD\nEFGH\nIJKL\nMNOP\nQRST\nUVWX\nYZ01\n2345\n6789';
            const lines = text.split('\n');
            const fontSize = 60;
            const baseLineHeight = 7 * lineSpacingMultiplier;
            
            // Generate random offsets if none exist
            if (Object.keys(letterDepthOffsets).length === 0) {
                console.log('Generating Z offsets for letters');
                let index = 0;
                lines.forEach(line => {
                    for (let i = 0; i < line.length; i++) {
                        letterDepthOffsets[index] = (Math.random() - 0.5) * 2;
                        index++;
                    }
                });
            }
            
            let charIndex = 0;
            lines.forEach((line, lineIndex) => {
                let currentX = 0;
                const lineWidth = calculateLineWidth(line, fontSize);
                currentX = -lineWidth / 2;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const glyph = font.charToGlyph(char);
                    const glyphWidth = (glyph.advanceWidth * fontSize / font.unitsPerEm) / 15;
                    
                    const x = currentX + glyphWidth / 2;
                    const y = -lineIndex * baseLineHeight + (lines.length * baseLineHeight) / 2 - baseLineHeight / 2;
                    
                    // Apply random Z offset using zOffsetMultiplier (NOT extrusionDepth)
                    const zOffset = letterDepthOffsets[charIndex] * zOffsetMultiplier * 0.5;
                    
                    createLetterFromFont(char, x, y, zOffset, fontSize);
                    
                    currentX += glyphWidth + (0.5 * letterSpacingMultiplier);
                    charIndex++;
                }
            });
        }

        function calculateLineWidth(line, fontSize) {
            let width = 0;
            for (let i = 0; i < line.length; i++) {
                const glyph = font.charToGlyph(line[i]);
                const glyphWidth = (glyph.advanceWidth * fontSize / font.unitsPerEm) / 15;
                width += glyphWidth + (0.5 * letterSpacingMultiplier);
            }
            return width - (0.5 * letterSpacingMultiplier);
        }

        function createLetterFromFont(char, x, y, z, fontSize) {
            const colors = [0xD4789C, 0xD4A95A, 0x6BA3C3, 0xE67E9F, 0xF4B860, 0x5A9BC4];
            const color = colors[char.charCodeAt(0) % colors.length];

            const glyph = font.charToGlyph(char);
            const path = glyph.getPath(0, 0, fontSize);
            
            const shapes = [];
            let currentShape = null;
            
            path.commands.forEach((cmd) => {
                if (cmd.type === 'M') {
                    if (currentShape) {
                        shapes.push(currentShape);
                    }
                    currentShape = new THREE.Shape();
                    currentShape.moveTo(-cmd.x / 15, -cmd.y / 15);
                } else if (cmd.type === 'L') {
                    currentShape.lineTo(-cmd.x / 15, -cmd.y / 15);
                } else if (cmd.type === 'C') {
                    currentShape.bezierCurveTo(
                        -cmd.x1 / 15, -cmd.y1 / 15,
                        -cmd.x2 / 15, -cmd.y2 / 15,
                        -cmd.x / 15, -cmd.y / 15
                    );
                } else if (cmd.type === 'Q') {
                    currentShape.quadraticCurveTo(
                        -cmd.x1 / 15, -cmd.y1 / 15,
                        -cmd.x / 15, -cmd.y / 15
                    );
                } else if (cmd.type === 'Z') {
                    currentShape.closePath();
                }
            });
            
            if (currentShape) {
                shapes.push(currentShape);
            }

            if (shapes.length === 0) return;

            if (shapes.length > 1) {
                const shapesWithArea = shapes.map(shape => {
                    const points = shape.getPoints();
                    let area = 0;
                    for (let i = 0; i < points.length; i++) {
                        const j = (i + 1) % points.length;
                        area += points[i].x * points[j].y;
                        area -= points[j].x * points[i].y;
                    }
                    return { shape, area: Math.abs(area) };
                });

                shapesWithArea.sort((a, b) => b.area - a.area);
                
                const mainShape = shapesWithArea[0].shape;
                const holes = shapesWithArea.slice(1).map(s => s.shape);
                
                holes.forEach(hole => {
                    mainShape.holes.push(hole);
                });

                const extrudeSettings = {
                    depth: extrusionDepth,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 2
                };
                
                const geometry = new THREE.ExtrudeGeometry(mainShape, extrudeSettings);
                geometry.rotateY(Math.PI);
                
                if (isItalic) {
                    for (let i = 0; i < geometry.attributes.position.count; i++) {
                        const y = geometry.attributes.position.getY(i);
                        const xOffset = y * 0.2;
                        geometry.attributes.position.setX(i, geometry.attributes.position.getX(i) + xOffset);
                    }
                    geometry.attributes.position.needsUpdate = true;
                }
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                textGroup.add(mesh);
            } else {
                const extrudeSettings = {
                    depth: extrusionDepth,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 2
                };
                
                const geometry = new THREE.ExtrudeGeometry(shapes[0], extrudeSettings);
                geometry.rotateY(Math.PI);
                
                if (isItalic) {
                    for (let i = 0; i < geometry.attributes.position.count; i++) {
                        const y = geometry.attributes.position.getY(i);
                        const xOffset = y * 0.2;
                        geometry.attributes.position.setX(i, geometry.attributes.position.getX(i) + xOffset);
                    }
                    geometry.attributes.position.needsUpdate = true;
                }
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                textGroup.add(mesh);
            }
        }

        function buildTextSimple() {
            console.log('Using fallback simple text');
            const text = 'ABCD\nEFGH\nIJKL\nMNOP\nQRST\nUVWX\nYZ01\n2345\n6789';
            const lines = text.split('\n');
            const letterSpacing = 4.5 * letterSpacingMultiplier;
            const lineHeight = 6;
            
            if (Object.keys(letterDepthOffsets).length === 0) {
                let charIndex = 0;
                lines.forEach((line) => {
                    for (let i = 0; i < line.length; i++) {
                        letterDepthOffsets[charIndex] = (Math.random() - 0.5) * 2;
                        charIndex++;
                    }
                });
            }
            
            let charIndex = 0;
            lines.forEach((line, lineIndex) => {
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const x = i * letterSpacing - (line.length * letterSpacing) / 2 + letterSpacing / 2;
                    const y = -lineIndex * lineHeight + (lines.length * lineHeight) / 2 - lineHeight / 2;
                    const z = letterDepthOffsets[charIndex] * zOffsetMultiplier * 0.5;
                    
                    const colors = [0xD4789C, 0xD4A95A, 0x6BA3C3, 0xE67E9F, 0xF4B860, 0x5A9BC4];
                    const color = colors[char.charCodeAt(0) % colors.length];
                    
                    const geometry = new THREE.BoxGeometry(3, 4, extrusionDepth);
                    const material = new THREE.MeshStandardMaterial({ color: color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    textGroup.add(mesh);
                    
                    charIndex++;
                }
            });
        }

        function setupControls() {
            const rotYSlider = document.getElementById('rotY');
            const rotXSlider = document.getElementById('rotX');
            const depthSlider = document.getElementById('depth');
            const zOffsetSlider = document.getElementById('zOffset');
            const spacingSlider = document.getElementById('spacing');
            const lineSpacingSlider = document.getElementById('lineSpacing');
            const fontSelect = document.getElementById('fontSelect');
            const boldBtn = document.getElementById('boldBtn');
            const italicBtn = document.getElementById('italicBtn');
            
            const rotYValue = document.getElementById('rotY-value');
            const rotXValue = document.getElementById('rotX-value');
            const depthValue = document.getElementById('depth-value');
            const zOffsetValue = document.getElementById('zOffset-value');
            const spacingValue = document.getElementById('spacing-value');
            const lineSpacingValue = document.getElementById('lineSpacing-value');

            rotYSlider.addEventListener('input', function() {
                const degrees = parseInt(this.value);
                textGroup.rotation.y = degrees * Math.PI / 180;
                rotYValue.textContent = degrees + '°';
            });

            rotXSlider.addEventListener('input', function() {
                const degrees = parseInt(this.value);
                textGroup.rotation.x = degrees * Math.PI / 180;
                rotXValue.textContent = degrees + '°';
            });

            depthSlider.addEventListener('input', function() {
                extrusionDepth = parseInt(this.value);
                depthValue.textContent = extrusionDepth;
                rebuildText();
            });

            zOffsetSlider.addEventListener('input', function() {
                zOffsetMultiplier = parseInt(this.value);
                zOffsetValue.textContent = zOffsetMultiplier;
                rebuildText();
            });

            spacingSlider.addEventListener('input', function() {
                letterSpacingMultiplier = parseFloat(this.value);
                spacingValue.textContent = letterSpacingMultiplier.toFixed(1);
                rebuildText();
            });

            lineSpacingSlider.addEventListener('input', function() {
                lineSpacingMultiplier = parseFloat(this.value);
                lineSpacingValue.textContent = lineSpacingMultiplier.toFixed(1);
                rebuildText();
            });

            fontSelect.addEventListener('change', function() {
                currentFontUrl = this.value;
                loadFont(currentFontUrl);
            });

            boldBtn.addEventListener('click', function() {
                isBold = !isBold;
                this.classList.toggle('active');
            });

            italicBtn.addEventListener('click', function() {
                isItalic = !isItalic;
                this.classList.toggle('active');
                rebuildText();
            });
        }

        function rebuildText() {
            while(textGroup.children.length > 0) {
                textGroup.remove(textGroup.children[0]);
            }
            buildText();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const maxLifetime = 240;
            
            raindropLights.forEach(drop => {
                drop.lifetime++;
                
                if (drop.lifetime > 0 && drop.fadeFactor > 0) {
                    drop.position.add(drop.velocity);
                    
                    let didCollide = false;
                    textGroup.children.forEach(letterMesh => {
                        const localPos = letterMesh.worldToLocal(drop.position.clone());
                        
                        if (!letterMesh.geometry.boundingBox) {
                            letterMesh.geometry.computeBoundingBox();
                        }
                        const box = letterMesh.geometry.boundingBox;
                        
                        if (box.containsPoint(localPos)) {
                            didCollide = true;
                            handleCollision(drop, letterMesh, localPos, box);
                        }
                    });
                }
                
                const outOfBounds = Math.abs(drop.position.x) > 60 || 
                                   Math.abs(drop.position.y) > 60 || 
                                   drop.position.z < -30 || 
                                   drop.position.z > 70;
                
                if (drop.lifetime > maxLifetime || outOfBounds) {
                    drop.fadeOut = true;
                }
                
                if (drop.fadeOut) {
                    drop.fadeFactor -= 0.05;
                    if (drop.fadeFactor <= 0) {
                        drop.position.set(0, 0, 50);
                        drop.velocity.set(
                            (Math.random() - 0.5) * 0.1,
                            (Math.random() - 0.5) * 0.1,
                            -1.5
                        );
                        drop.fadeOut = false;
                        drop.fadeFactor = 0;
                        drop.lifetime = 0;
                    }
                } else if (drop.lifetime > 0) {
                    drop.fadeFactor = Math.min(1.0, drop.fadeFactor + 0.1);
                }
                
                const flicker = 0.7 + Math.random() * 0.6;
                drop.light.intensity = drop.baseIntensity * flicker * drop.fadeFactor;
                
                drop.light.position.copy(drop.position);
            });
            
            renderer.render(scene, camera);
        }

        function handleCollision(drop, mesh, localPos, boundingBox) {
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            
            const dx = Math.abs(localPos.x - center.x);
            const dy = Math.abs(localPos.y - center.y);
            const dz = Math.abs(localPos.z - center.z);
            
            const halfSize = new THREE.Vector3();
            boundingBox.getSize(halfSize).multiplyScalar(0.5);
            
            const penetrationX = halfSize.x - dx;
            const penetrationY = halfSize.y - dy;
            const penetrationZ = halfSize.z - dz;
            
            let normal = new THREE.Vector3();
            
            if (penetrationX < penetrationY && penetrationX < penetrationZ) {
                normal.set(localPos.x > center.x ? 1 : -1, 0, 0);
            } else if (penetrationY < penetrationZ) {
                normal.set(0, localPos.y > center.y ? 1 : -1, 0);
            } else {
                normal.set(0, 0, localPos.z > center.z ? 1 : -1);
            }
            
            const worldNormal = normal.applyMatrix3(new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld)).normalize();
            
            const dotProduct = drop.velocity.dot(worldNormal);
            const reflection = worldNormal.clone().multiplyScalar(2 * dotProduct);
            drop.velocity.sub(reflection);
            
            drop.velocity.multiplyScalar(0.75);
            
            const pushOut = worldNormal.clone().multiplyScalar(1.5);
            drop.position.add(pushOut);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
