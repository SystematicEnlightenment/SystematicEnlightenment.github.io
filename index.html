<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NYE2026_SysEn</title>https://github.com/SystematicEnlightenment/SystematicEnlightenment.github.io/edit/main/index.html
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            color: white;
            min-width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        #controls.minimized {
            min-width: auto;
            padding: 10px;
        }
        #controls.minimized .control-content {
            display: none;
        }
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        #controls.minimized .control-header {
            margin-bottom: 0;
        }
        .control-title {
            font-size: 16px;
            font-weight: bold;
        }
        .toggle-btn {
            background: #3498db;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .toggle-btn:hover {
            background: #2980b9;
        }
        .control-content {
            display: block;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
        }
        input[type="range"] {
            width: 100%;
        }
        select {
            width: 100%;
            padding: 8px;
            background: #2a2a3e;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 14px;
        }
        .button-group {
            display: flex;
            gap: 10px;
        }
        button {
            flex: 1;
            padding: 10px;
            background: #2a2a3e;
            color: white;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button.active {
            background: #3498db;
            border-color: #3498db;
        }
        button:hover {
            background: #3a3a4e;
        }
        button.active:hover {
            background: #2980b9;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #3498db;
        }
    </style>
</head>
<body>
    <div id="controls" class="minimized">
        <div class="control-header">
            <div class="control-title">Controls</div>
            <button class="toggle-btn" id="toggleControls">Minimize</button>
        </div>
        <div class="control-content">
        <div class="control-group">
            <label>Font:</label>
            <select id="fontSelect">
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/anton@5.0.17/files/anton-latin-400-normal.woff">Anton</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/source-code-pro@5.0.8/files/source-code-pro-latin-700-normal.woff">Source Code Pro Bold</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/roboto@5.0.8/files/roboto-latin-700-normal.woff">Roboto Bold</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/open-sans@5.0.17/files/open-sans-latin-700-normal.woff">Open Sans Bold</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/pacifico@5.0.10/files/pacifico-latin-400-normal.woff">Pacifico</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/permanent-marker@5.0.9/files/permanent-marker-latin-400-normal.woff">Permanent Marker</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/indie-flower@5.0.10/files/indie-flower-latin-400-normal.woff">Indie Flower</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/press-start-2p@5.0.9/files/press-start-2p-latin-400-normal.woff">Press Start 2P</option>
                <option value="https://cdn.jsdelivr.net/npm/@fontsource/righteous@5.0.17/files/righteous-latin-400-normal.woff">Righteous</option>
            </select>
        </div>
        <div class="control-group">
            <label>Font Style:</label>
            <div class="button-group">
                <button id="boldBtn" class="active">Bold</button>
                <button id="italicBtn" class="active">Italic</button>
            </div>
        </div>
        <div class="control-group">
            <label>Letter Spacing: <span class="value-display" id="spacing-value">0.2</span></label>
            <input type="range" id="spacing" min="0" max="3" value="0.2" step="0.1">
        </div>
        <div class="control-group">
            <label>Line Spacing: <span class="value-display" id="lineSpacing-value">0.6</span></label>
            <input type="range" id="lineSpacing" min="0.5" max="3" value="0.6" step="0.1">
        </div>
        <div class="control-group">
            <label>Rotation Y (0-360Â°): <span class="value-display" id="rotY-value">17Â°</span></label>
            <input type="range" id="rotY" min="0" max="360" value="17" step="1">
        </div>
        <div class="control-group">
            <label>Rotation X (-90 to 90Â°): <span class="value-display" id="rotX-value">-9Â°</span></label>
            <input type="range" id="rotX" min="-90" max="90" value="-9" step="1">
        </div>
        <div class="control-group">
            <label>Extrusion Depth (1-500): <span class="value-display" id="depth-value">500</span></label>
            <input type="range" id="depth" min="1" max="500" value="500" step="1">
        </div>
        <div class="control-group">
            <label>Z Offset (0-150): <span class="value-display" id="zOffset-value">5</span></label>
            <input type="range" id="zOffset" min="0" max="150" value="5" step="1">
        </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.4/opentype.min.js"></script>
    <script>
        let scene, camera, renderer, textGroup;
        let extrusionDepth = 500;
        let zOffsetMultiplier = 5;
        let font = null;
        let letterSpacingMultiplier = 0.2;  // Change from 1.0
        let lineSpacingMultiplier = 0.6;    // Change from 0.5
        let isBold = true;                   // Already true
        let isItalic = true;                 // Change from false
        let currentFontUrl = 'https://cdn.jsdelivr.net/npm/@fontsource/anton@5.0.17/files/anton-latin-400-normal.woff';  // Change to Anton
        let raindropLights = [];
        let letterDepthOffsets = {};
        let lightPool = [];
        let zOffsetAnimationStart = null;
        let zOffsetAnimationDuration = 4000; // 4 seconds in milliseconds        
        let ambientLight;
        
        function init() {
            scene = new THREE.Scene();
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 60);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e);
            document.body.appendChild(renderer.domElement);
        
            ambientLight = new THREE.AmbientLight(0xffffff, 0.15);
            scene.add(ambientLight);
            
            const planeGeometry = new THREE.PlaneGeometry(500, 500);
            const planeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2a2a3e,
                metalness: 0.1,
                roughness: 0.8
            });
            const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.position.y = -32;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            
            const neonColors = [0x00ffff, 0x00ff00, 0xffffff];
            
            const light1Color = neonColors[Math.floor(Math.random() * neonColors.length)];
            const light1 = new THREE.PointLight(light1Color, 2.5, 80);
            light1.position.set(0, 50, 5);
            light1.castShadow = true;
            scene.add(light1);
            const sphere1 = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: light1Color })
            );
            light1.add(sphere1);
            
            const light2Color = neonColors[Math.floor(Math.random() * neonColors.length)];
            const light2 = new THREE.PointLight(light2Color, 2.5, 80);
            light2.position.set(0, 50, 5);
            light2.castShadow = true;
            scene.add(light2);
            const sphere2 = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: light2Color })
            );
            light2.add(sphere2);
        
            for (let i = 0; i < 30; i++) {
                const lightColor = neonColors[Math.floor(Math.random() * neonColors.length)];
                const light = new THREE.PointLight(lightColor, 0, 80);
                light.position.set(0, 0, 60);
                light.castShadow = false;
                scene.add(light);
                const sphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: lightColor })
                );
                light.add(sphere);
                lightPool.push({ light: light, color: lightColor, inUse: false });
            }
        
            raindropLights = [
                { light: light1, position: new THREE.Vector3(0, 0, 60), velocity: new THREE.Vector3(0, 0, 0), baseIntensity: 2.5, fadeOut: false, fadeFactor: 0, lifetime: 0, isStable: false, stableTime: 0, stableFrameCount: 0 },
                { light: light2, position: new THREE.Vector3(0, 0, 60), velocity: new THREE.Vector3(0, 0, 0), baseIntensity: 2.5, fadeOut: false, fadeFactor: 0, lifetime: -1, isStable: false, stableTime: 0, stableFrameCount: 0 }
            ];
        
            textGroup = new THREE.Group();
            textGroup.rotation.y = 17 * Math.PI / 180;
            textGroup.rotation.x = -9 * Math.PI / 180;
            scene.add(textGroup);
        
            loadFont(currentFontUrl);
            setupControls();
            window.addEventListener('resize', onWindowResize);
        
            // Set initial zOffset to 100
            zOffsetMultiplier = 100;
            document.getElementById('zOffset').value = 100;
            document.getElementById('zOffset-value').textContent = 100;
            
            // Animation will start when animate() begins
            zOffsetAnimationStart = Date.now();
        
            // Performance test before starting animation
            let testStartTime = performance.now();
            let testFrames = 0;
            let testDuration = 1000; // Test for 1 second
        
            function performanceTest() {
                testFrames++;
                let elapsed = performance.now() - testStartTime;
                
                if (elapsed < testDuration) {
                    renderer.render(scene, camera);
                    requestAnimationFrame(performanceTest);
                } else {
                    let fps = (testFrames / elapsed) * 1000;
                    console.log(`Performance test: ${fps.toFixed(1)} FPS`);
                    
                    // Adjust light pool size based on performance
                    let maxLights = 30; // Default
                    if (fps < 30) {
                        maxLights = 10; // Low performance
                        console.log('Low performance detected - using 10 lights');
                    } else if (fps < 45) {
                        maxLights = 20; // Medium performance
                        console.log('Medium performance detected - using 20 lights');
                    } else {
                        console.log('Good performance detected - using 30 lights');
                    }
                    
                    // Adjust the light pool to match performance
                    while (lightPool.length > maxLights) {
                        let removed = lightPool.pop();
                        scene.remove(removed.light);
                    }
                    
                    // Now start the main animation
                    animate();
                }
            }
            
            // Start performance test instead of animate()
            performanceTest();
        }

        function loadFont(url) {
            opentype.load(url, function(err, loadedFont) {
                if (err) {
                    console.error('Font loading error:', err);
                    buildTextSimple();
                } else {
                    font = loadedFont;
                    rebuildText();
                }
            });
        }

        function buildText() {
            if (!font) {
                buildTextSimple();
                return;
            }

            //const text = 'ABCD\nEFGH\nIJKL\nMNOP\nQRST\nUVWX\nYZ01\n2345\n6789';
            const text = 'Systematic\nEnlightenment3\nNewYearsEve2026\nTheQueensHead\nEastville park\nBristol\nSetTimesTBC\nBringOrDonate\nCashForGaza\nFreeEntry';
            const lines = text.split('\n');
            const fontSize = 60;
            const baseLineHeight = 7 * lineSpacingMultiplier;
            
            if (Object.keys(letterDepthOffsets).length === 0) {
                console.log('Generating Z offsets for letters');
                let index = 0;
                lines.forEach(line => {
                    for (let i = 0; i < line.length; i++) {
                        letterDepthOffsets[index] = (Math.random() - 0.5) * 2;
                        index++;
                    }
                });
            }
            
            let charIndex = 0;
            lines.forEach((line, lineIndex) => {
                let currentX = 0;
                const lineWidth = calculateLineWidth(line, fontSize);
                currentX = -lineWidth / 2;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const glyph = font.charToGlyph(char);
                    const glyphWidth = (glyph.advanceWidth * fontSize / font.unitsPerEm) / 15;
                    
                    // Apply kerning if there's a next character and font has kerning
                    let kerning = 0;
                    if (i < line.length - 1 && font.getKerningValue) {
                        const nextChar = line[i + 1];
                        const nextGlyph = font.charToGlyph(nextChar);
                        const kernValue = font.getKerningValue(glyph, nextGlyph);
                        kerning = (kernValue * fontSize / font.unitsPerEm) / 15;
                    }
                    
                    const x = currentX + glyphWidth / 2;
                    const y = -28 + (lines.length - 1 - lineIndex) * baseLineHeight;
                    const zOffset = letterDepthOffsets[charIndex] * zOffsetMultiplier * 0.5;
                    
                    createLetterFromFont(char, x, y, zOffset, fontSize, lineIndex);
                    
                    currentX += glyphWidth + kerning + (0.5 * letterSpacingMultiplier);
                    charIndex++;
                }
            });
        }

        function calculateLineWidth(line, fontSize) {
            let width = 0;
            for (let i = 0; i < line.length; i++) {
                const glyph = font.charToGlyph(line[i]);
                const glyphWidth = (glyph.advanceWidth * fontSize / font.unitsPerEm) / 15;
                width += glyphWidth + (0.5 * letterSpacingMultiplier);
            }
            return width - (0.5 * letterSpacingMultiplier);
        }

        function createLetterFromFont(char, x, y, z, fontSize, lineIndex) {
            const colors = [0x8B4789, 0x4A7BA7];  // Darker purple and blue (2 colors)
            const color = colors[lineIndex % colors.length];

            const glyph = font.charToGlyph(char);
            const path = glyph.getPath(0, 0, fontSize);
            
            const shapes = [];
            let currentShape = null;
            
            path.commands.forEach((cmd) => {
                if (cmd.type === 'M') {
                    if (currentShape) {
                        shapes.push(currentShape);
                    }
                    currentShape = new THREE.Shape();
                    currentShape.moveTo(-cmd.x / 15, -cmd.y / 15);
                } else if (cmd.type === 'L') {
                    currentShape.lineTo(-cmd.x / 15, -cmd.y / 15);
                } else if (cmd.type === 'C') {
                    currentShape.bezierCurveTo(
                        -cmd.x1 / 15, -cmd.y1 / 15,
                        -cmd.x2 / 15, -cmd.y2 / 15,
                        -cmd.x / 15, -cmd.y / 15
                    );
                } else if (cmd.type === 'Q') {
                    currentShape.quadraticCurveTo(
                        -cmd.x1 / 15, -cmd.y1 / 15,
                        -cmd.x / 15, -cmd.y / 15
                    );
                } else if (cmd.type === 'Z') {
                    currentShape.closePath();
                }
            });
            
            if (currentShape) {
                shapes.push(currentShape);
            }

            if (shapes.length === 0) return;

            if (shapes.length > 1) {
                const shapesWithArea = shapes.map(shape => {
                    const points = shape.getPoints();
                    let area = 0;
                    for (let i = 0; i < points.length; i++) {
                        const j = (i + 1) % points.length;
                        area += points[i].x * points[j].y;
                        area -= points[j].x * points[i].y;
                    }
                    return { shape, area: Math.abs(area) };
                });

                shapesWithArea.sort((a, b) => b.area - a.area);
                
                const mainShape = shapesWithArea[0].shape;
                const holes = shapesWithArea.slice(1).map(s => s.shape);
                
                holes.forEach(hole => {
                    mainShape.holes.push(hole);
                });

                const extrudeSettings = {
                    depth: extrusionDepth,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 2
                };
                
                const geometry = new THREE.ExtrudeGeometry(mainShape, extrudeSettings);
                geometry.rotateY(Math.PI);
                
                if (isItalic) {
                    for (let i = 0; i < geometry.attributes.position.count; i++) {
                        const y = geometry.attributes.position.getY(i);
                        const xOffset = y * 0.2;
                        geometry.attributes.position.setX(i, geometry.attributes.position.getX(i) + xOffset);
                    }
                    geometry.attributes.position.needsUpdate = true;
                }
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                textGroup.add(mesh);
            } else {
                const extrudeSettings = {
                    depth: extrusionDepth,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 2
                };
                
                const geometry = new THREE.ExtrudeGeometry(shapes[0], extrudeSettings);
                geometry.rotateY(Math.PI);
                
                if (isItalic) {
                    for (let i = 0; i < geometry.attributes.position.count; i++) {
                        const y = geometry.attributes.position.getY(i);
                        const xOffset = y * 0.2;
                        geometry.attributes.position.setX(i, geometry.attributes.position.getX(i) + xOffset);
                    }
                    geometry.attributes.position.needsUpdate = true;
                }
                
                const material = new THREE.MeshStandardMaterial({ 
                    color: color,
                    metalness: 0.3,
                    roughness: 0.4
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y, z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                textGroup.add(mesh);
            }
        }

        function buildTextSimple() {
            console.log('Using fallback simple text');
            const text = 'ABCD\nEFGH\nIJKL\nMNOP\nQRST\nUVWX\nYZ01\n2345\n6789';
            const lines = text.split('\n');
            const letterSpacing = 4.5 * letterSpacingMultiplier;
            const lineHeight = 6;
            
            if (Object.keys(letterDepthOffsets).length === 0) {
                let charIndex = 0;
                lines.forEach((line) => {
                    for (let i = 0; i < line.length; i++) {
                        letterDepthOffsets[charIndex] = (Math.random() - 0.5) * 2;
                        charIndex++;
                    }
                });
            }
            
            let charIndex = 0;
            lines.forEach((line, lineIndex) => {
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    const x = i * letterSpacing - (line.length * letterSpacing) / 2 + letterSpacing / 2;
                    const y = -lineIndex * lineHeight + (lines.length * lineHeight) / 2 - lineHeight / 2;
                    const z = letterDepthOffsets[charIndex] * zOffsetMultiplier * 0.5;
                    
                    const colors = [0x8B4789, 0x4A7BA7];  // Darker purple and blue (2 colors)
                    const color = colors[lineIndex % colors.length];  // Use lineIndex instead of char
                    
                    const geometry = new THREE.BoxGeometry(3, 4, extrusionDepth);
                    const material = new THREE.MeshStandardMaterial({ color: color });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    textGroup.add(mesh);
                    
                    charIndex++;
                }
            });
        }

        function setupControls() {
            const toggleBtn = document.getElementById('toggleControls');
            const controlsPanel = document.getElementById('controls');
            
            toggleBtn.textContent = 'Expand'; // Set initial text
            
            toggleBtn.addEventListener('click', function() {
                controlsPanel.classList.toggle('minimized');
                this.textContent = controlsPanel.classList.contains('minimized') ? 'Expand' : 'Minimize';
            });
            
            const rotYSlider = document.getElementById('rotY');
            const rotXSlider = document.getElementById('rotX');
            const depthSlider = document.getElementById('depth');
            const zOffsetSlider = document.getElementById('zOffset');
            const spacingSlider = document.getElementById('spacing');
            const lineSpacingSlider = document.getElementById('lineSpacing');
            const fontSelect = document.getElementById('fontSelect');
            const boldBtn = document.getElementById('boldBtn');
            const italicBtn = document.getElementById('italicBtn');
            
            const rotYValue = document.getElementById('rotY-value');
            const rotXValue = document.getElementById('rotX-value');
            const depthValue = document.getElementById('depth-value');
            const zOffsetValue = document.getElementById('zOffset-value');
            const spacingValue = document.getElementById('spacing-value');
            const lineSpacingValue = document.getElementById('lineSpacing-value');
        
            rotYSlider.addEventListener('input', function() {
                const degrees = parseInt(this.value);
                textGroup.rotation.y = degrees * Math.PI / 180;
                rotYValue.textContent = degrees + 'Â°';
            });
        
            rotXSlider.addEventListener('input', function() {
                const degrees = parseInt(this.value);
                textGroup.rotation.x = degrees * Math.PI / 180;
                rotXValue.textContent = degrees + 'Â°';
            });
        
            depthSlider.addEventListener('input', function() {
                extrusionDepth = parseInt(this.value);
                depthValue.textContent = extrusionDepth;
                rebuildText();
            });
        
            zOffsetSlider.addEventListener('input', function() {
                zOffsetMultiplier = parseInt(this.value);
                zOffsetValue.textContent = zOffsetMultiplier;
                rebuildText();
            });
        
            spacingSlider.addEventListener('input', function() {
                letterSpacingMultiplier = parseFloat(this.value);
                spacingValue.textContent = letterSpacingMultiplier.toFixed(1);
                rebuildText();
            });
        
            lineSpacingSlider.addEventListener('input', function() {
                lineSpacingMultiplier = parseFloat(this.value);
                lineSpacingValue.textContent = lineSpacingMultiplier.toFixed(1);
                rebuildText();
            });
        
            fontSelect.addEventListener('change', function() {
                currentFontUrl = this.value;
                loadFont(currentFontUrl);
            });
        
            boldBtn.addEventListener('click', function() {
                isBold = !isBold;
                this.classList.toggle('active');
            });
        
            italicBtn.addEventListener('click', function() {
                isItalic = !isItalic;
                this.classList.toggle('active');
                rebuildText();
            });
        }

        function rebuildText() {
            while(textGroup.children.length > 0) {
                textGroup.remove(textGroup.children[0]);
            }
            buildText();
        }

        function animate() {
            requestAnimationFrame(animate);

            // Animate zOffset from 100 to 0 over 4 seconds
            if (zOffsetAnimationStart !== null) {
                let elapsed = Date.now() - zOffsetAnimationStart;
                if (elapsed >= zOffsetAnimationDuration) {
                    zOffsetMultiplier = 0;
                    document.getElementById('zOffset').value = 0;
                    document.getElementById('zOffset-value').textContent = 0;
                    zOffsetAnimationStart = null; // Stop animation
                    
                    // Set final positions
                    textGroup.children.forEach((mesh, index) => {
                        mesh.position.z = 0;
                    });
                } else {
                    let progress = elapsed / zOffsetAnimationDuration;
                    zOffsetMultiplier = 100 * (1 - progress);
                    document.getElementById('zOffset').value = zOffsetMultiplier;
                    document.getElementById('zOffset-value').textContent = Math.round(zOffsetMultiplier);
                    
                    // Smoothly move existing letters
                    textGroup.children.forEach((mesh, index) => {
                        mesh.position.z = letterDepthOffsets[index] * zOffsetMultiplier * 0.5;
                    });
                }
            }            
            
            // SPEED INCREASED: dt from 0.5 to 1.5 (3x faster)
            const gravity = new THREE.Vector3(0, -0.2, 0);
            const groundY = -31.5;
            const friction = 0.97;
            const bounceDampening = 0.7;
            const stabilityThreshold = 0.15; // Increased to make it easier to detect stopped lights
            const dt = 1.5; // 3x faster physics!
            
            raindropLights.forEach((drop, index) => {
                if (drop.isStable) {
                    drop.stableTime++;
                    const flicker = 0.7 + Math.random() * 0.6;
                    drop.light.intensity = drop.baseIntensity * flicker;
                    return;
                }
                
                if (drop.lifetime < 0) {
                    let canLaunch = false;
                    for (let i = 0; i < index; i++) {
                        if (raindropLights[i].isStable) {
                            canLaunch = true;
                            break;
                        }
                    }
                    if (index === 0 || canLaunch) {
                        launchLight(drop);
                    }
                    return;
                }
                
                drop.lifetime++;
                
                if (drop.lifetime > 0) {
                    drop.velocity.add(gravity.clone().multiplyScalar(dt));
                    drop.position.add(drop.velocity.clone().multiplyScalar(dt));
                    
                    const outOfBounds = Math.abs(drop.position.x) > 100 || 
                                       drop.position.y < -50 || 
                                       drop.position.y > 100 ||
                                       Math.abs(drop.position.z) > 100;
                    
                    if (outOfBounds) {
                        console.log(`Light ${index} went out of bounds, getting new light from pool`);
                        drop.isStable = true;
                        drop.light.intensity = 0;
                        getNextLightFromPool();
                        return;
                    }
                    
                    if (drop.position.y <= groundY) {
                        drop.position.y = groundY;
                        
                        if (Math.abs(drop.velocity.y) > 0.1) {
                            drop.velocity.y = -drop.velocity.y * bounceDampening;
                        } else {
                            drop.velocity.y = 0;
                        }
                        
                        drop.velocity.x *= friction;
                        drop.velocity.z *= friction;
                        
                        // Simple stability check like original - no frame counter needed
                        const horizontalSpeed = Math.sqrt(drop.velocity.x * drop.velocity.x + drop.velocity.z * drop.velocity.z);
                        if (horizontalSpeed < stabilityThreshold && Math.abs(drop.velocity.y) < stabilityThreshold) {
                            drop.isStable = true;
                            drop.velocity.set(0, 0, 0);
                            console.log(`Light ${index} stabilized at:`, drop.position);
                            getNextLightFromPool();
                        }
                    }
                    
                    textGroup.children.forEach(letterMesh => {
                        const localPos = letterMesh.worldToLocal(drop.position.clone());
                        
                        if (!letterMesh.geometry.boundingBox) {
                            letterMesh.geometry.computeBoundingBox();
                        }
                        const box = letterMesh.geometry.boundingBox;
                        
                        if (box.containsPoint(localPos)) {
                            handleCollision(drop, letterMesh, localPos, box);
                        }
                    });
                    
                    drop.fadeFactor = Math.min(1.0, drop.fadeFactor + 0.1);
                }
                
                const flicker = 0.7 + Math.random() * 0.6;
                drop.light.intensity = drop.baseIntensity * flicker * drop.fadeFactor;
                drop.light.position.copy(drop.position);
            });

            // Gradually increase camera light 2 seconds after the last light drops
            if (window.lastLightDropped && !window.brightnessAnimationComplete) {
                if (!window.brightnessAnimationStart) {
                    window.brightnessAnimationStart = Date.now();
                    
                    // Create a spotlight from the camera
                    window.cameraLight = new THREE.SpotLight(0xffffff, 0, 100, Math.PI / 6, 0.5, 2);
                    window.cameraLight.position.copy(camera.position);
                    window.cameraLight.target.position.set(0, 0, 0);
                    scene.add(window.cameraLight);
                    scene.add(window.cameraLight.target);
                    
                    console.log('ðŸ”† Starting camera light animation');
                }
                
                const elapsed = (Date.now() - window.brightnessAnimationStart) / 1000;
                
                // Wait 2 seconds before starting the brightness increase
                if (elapsed >= 2 && elapsed < 5) {
                    // Increase intensity over 3 seconds (after the 2 second wait)
                    const progress = (elapsed - 2) / 3;
                    window.cameraLight.intensity = 3.0 * progress; // Ramp up to intensity 3.0
                    console.log('ðŸ”† Camera light intensity:', window.cameraLight.intensity.toFixed(3));
                } else if (elapsed >= 5) {
                    window.cameraLight.intensity = 3.0; // Final intensity
                    window.brightnessAnimationComplete = true;
                    console.log('ðŸ”† Camera light animation complete! Final intensity:', window.cameraLight.intensity);
                }
            }
            
            renderer.render(scene, camera);
        }

        function launchLight(drop) {
            const isLastLight = raindropLights.length >= lightPool.length + 2;
            
            if (isLastLight) {
                // Special handling for last light - drop vertically in front of text
                const rotY = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
                const rotX = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
                
                // Calculate distance in front of text (half text height)
                const textHeight = 35; // Approximate text height
                const frontDistance = textHeight * 0.5;
                
                // Position is offset based on rotation to be in front of text center
                const offsetZ = frontDistance * Math.cos(rotY);
                const offsetX = frontDistance * Math.sin(rotY);
                
                // Start position high above
                drop.position.set(offsetX, 40, offsetZ);
                // Zero horizontal velocity - pure vertical drop
                drop.velocity.set(0, 0, 0);
                drop.lifetime = 0;
                drop.fadeFactor = 0;
                drop.baseIntensity = 4.0;  // ADD THIS LINE - Much brighter than regular lights (2.5)
                window.lastLightDropped = true;  // ADD THIS LINE
                
                console.log(`Last light dropping vertically at (${offsetX.toFixed(1)}, 40, ${offsetZ.toFixed(1)}) - front of text based on rotY=${(rotY * 180 / Math.PI).toFixed(1)}Â°`);
                return;
            }
            
            const cameraPos = new THREE.Vector3(0, 0, 60);
            
            const targetX = (Math.random() - 0.5) * 25;
            const targetY = (Math.random() - 0.5) * 35;
            const targetZ = 10 + Math.random() * 30;
            const textTarget = new THREE.Vector3(targetX, targetY, targetZ);
            
            const launchAngle = (20 + Math.random() * 10) * Math.PI / 180;
            const g = 0.2;
            
            const direction = new THREE.Vector3()
                .subVectors(textTarget, cameraPos);
            const horizontalDist = Math.sqrt(direction.x * direction.x + direction.z * direction.z);
            const verticalDist = targetY - cameraPos.y;
            
            const tanAngle = Math.tan(launchAngle);
            const cosAngle = Math.cos(launchAngle);
            const sinAngle = Math.sin(launchAngle);
            
            const sin2Angle = Math.sin(2 * launchAngle);
            const denominator = sin2Angle - (2 * cosAngle * cosAngle * verticalDist / horizontalDist);
            
            let v0;
            if (denominator > 0) {
                v0 = Math.sqrt((g * horizontalDist) / denominator);
            } else {
                v0 = Math.sqrt((g * horizontalDist) / (2 * cosAngle * cosAngle * tanAngle));
            }
            
            v0 *= (0.1 + Math.random() * 0.9);
            
            direction.normalize();
            const horizontalDir = new THREE.Vector3(direction.x, 0, direction.z).normalize();
            
            const vx = horizontalDir.x * v0 * cosAngle;
            const vy = v0 * sinAngle;
            const vz = horizontalDir.z * v0 * cosAngle;
            
            drop.position.set(0, 0, 60);
            drop.velocity.set(vx, vy, vz);
            drop.lifetime = 0;
            drop.fadeFactor = 0;
            
            console.log(`Launching light to target (${targetX.toFixed(1)}, ${targetY.toFixed(1)}, ${targetZ.toFixed(1)}) at ${(launchAngle * 180 / Math.PI).toFixed(1)}Â° with v0=${v0.toFixed(2)}`);
        }

        function getNextLightFromPool() {
            const availableLight = lightPool.find(l => !l.inUse);
            
            if (!availableLight) {
                console.log('Light pool exhausted! All 30 lights in use.');
                return;
            }
            
            availableLight.inUse = true;
            
            raindropLights.push({
                light: availableLight.light,
                position: new THREE.Vector3(0, 0, 60),
                velocity: new THREE.Vector3(0, 0, 0),
                baseIntensity: 2.5,
                fadeOut: false,
                fadeFactor: 0,
                lifetime: -1,
                isStable: false,
                stableTime: 0,
                stableFrameCount: 0
            });

            // Check if this is the last light and make it blue
            if (raindropLights.length >= lightPool.length + 2) {
                availableLight.light.color.setHex(0x0088ff); // Bright blue
                availableLight.light.children[0].material.color.setHex(0x0088ff); // Sphere color
            }            
            
            console.log(`Activated light from pool. Active lights: ${raindropLights.filter(d => !d.isStable || d.light.intensity > 0).length}`);
        }

        function handleCollision(drop, mesh, localPos, boundingBox) {
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            
            const dx = Math.abs(localPos.x - center.x);
            const dy = Math.abs(localPos.y - center.y);
            const dz = Math.abs(localPos.z - center.z);
            
            const halfSize = new THREE.Vector3();
            boundingBox.getSize(halfSize).multiplyScalar(0.5);
            
            const penetrationX = halfSize.x - dx;
            const penetrationY = halfSize.y - dy;
            const penetrationZ = halfSize.z - dz;
            
            let normal = new THREE.Vector3();
            
            if (penetrationX < penetrationY && penetrationX < penetrationZ) {
                normal.set(localPos.x > center.x ? 1 : -1, 0, 0);
            } else if (penetrationY < penetrationZ) {
                normal.set(0, localPos.y > center.y ? 1 : -1, 0);
            } else {
                normal.set(0, 0, localPos.z > center.z ? 1 : -1);
            }
            
            const worldNormal = normal.applyMatrix3(new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld)).normalize();
            
            const dotProduct = drop.velocity.dot(worldNormal);
            const reflection = worldNormal.clone().multiplyScalar(2 * dotProduct);
            drop.velocity.sub(reflection);
            
            const pushOut = worldNormal.clone().multiplyScalar(1.5);
            drop.position.add(pushOut);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
